
6:44
"Redis为什么快？"
A: Redis快的原因主要有几个方面：

1. **内存存储**：Redis是纯内存数据库，避免了磁盘IO，内存访问速度比磁盘快几个数量级

2. **单线程模型**：Redis使用单线程处理命令，避免了线程切换和锁竞争的开销，同时保证了操作的原子性

3. **高效的数据结构**：Redis针对不同场景优化了数据结构，如SDS字符串、跳跃表、压缩列表等，操作复杂度低

4. **IO多路复用**：使用epoll等机制处理网络IO，可以同时处理大量客户端连接而不阻塞

5. **协议简单**：Redis协议RESP简单高效，解析开销小

6. **无SQL解析**：直接执行命令，没有SQL解析的开销

7:47
"我看你 写了节省了数据库的IO次数，那你们在高并发的环境下，缓存跟数据库的读写顺序，你们是怎么设计的？"
A: 在高并发环境下，我们采用了多层次的缓存策略：

**读操作流程：**
1. **Cache Aside模式**：先查缓存，缓存命中直接返回；缓存未命中则查数据库，然后更新缓存
2. **多级缓存**：本地缓存(Caffeine) -> 分布式缓存(Redis) -> 数据库，逐层降级
3. **缓存预热**：系统启动时预加载热点数据，避免缓存穿透

**写操作流程：**
1. **先更新数据库，再删除缓存**：保证数据一致性，避免脏数据
2. **延迟双删策略**：删除缓存 -> 更新数据库 -> 延迟删除缓存，处理并发读写问题
3. **异步更新**：对于非强一致性要求的场景，使用MQ异步更新缓存

**一致性保障：**
- 使用分布式锁防止缓存击穿
- 设置合理的TTL避免数据过期
- 监控缓存命中率，及时调整策略

09:53
"然后我看你有写接口优化的一些方面是吧……优化了325倍除了用Redis 加 多线程以外，数据库层面有没有做一些优化呢?"
A: 数据库层面我们做了全方位的优化：

**索引优化：**
1. **复合索引设计**：根据查询条件建立最左前缀匹配的复合索引
2. **覆盖索引**：让查询字段都包含在索引中，避免回表操作
3. **索引下推**：在索引层面就过滤数据，减少回表次数

**SQL优化：**
1. **避免全表扫描**：优化WHERE条件，确保走索引
2. **分页优化**：使用延迟关联或子查询优化深度分页
3. **批量操作**：使用批量插入/更新减少网络开销

**架构优化：**
1. **读写分离**：主库写，从库读，分散数据库压力
2. **分库分表**：水平拆分大表，提高查询效率
3. **连接池优化**：合理配置连接池参数，避免连接泄漏

**存储优化：**
- 选择合适的存储引擎（InnoDB）
- 优化MySQL配置参数
- 定期分析表结构和执行计划

14:54
"具体从SQL处做深度分页优化，这个了不了解？就比如说我现在让你写一个SQL语句，需要你从100万数据开始查，查到100数据中的第一条"
"其实用子查询也可以"
A: 深度分页是个经典问题，我来展示几种优化方案：

**问题分析：**
传统的LIMIT 1000000, 1会扫描前100万条记录然后丢弃，效率极低。

**优化方案一：延迟关联**
```sql
SELECT t.* FROM table_name t 
INNER JOIN (
    SELECT id FROM table_name 
    ORDER BY id LIMIT 1000000, 1
) tmp ON t.id = tmp.id;
```

**优化方案二：基于游标的分页**
```sql
-- 假设上次查询的最大ID是999999
SELECT * FROM table_name 
WHERE id > 999999 
ORDER BY id LIMIT 1;
```

**优化方案三：二分查找法**
```sql
-- 先获取总数，然后二分定位
SELECT * FROM table_name 
WHERE id >= (
    SELECT id FROM table_name 
    ORDER BY id LIMIT 1000000, 1
) LIMIT 1;
```

**最佳实践：**
- 避免使用OFFSET进行深度分页
- 使用业务主键或时间戳作为游标
- 前端配合实现"加载更多"而非跳页

15:38
"你之前做过分布式系统吗？"  （我回答了多个系统微服务调用）
A: 是的，我有丰富的分布式系统开发经验。主要涉及：

**微服务架构设计：**
- 基于Spring Cloud构建微服务体系
- 服务注册发现（Eureka/Nacos）
- 配置中心（Apollo/Nacos）
- 服务网关（Gateway/Zuul）

**服务间通信：**
- 同步调用：Feign/RestTemplate
- 异步消息：RabbitMQ/Kafka
- RPC框架：Dubbo

**分布式治理：**
- 熔断降级（Hystrix/Sentinel）
- 链路追踪（Zipkin/SkyWalking）
- 服务监控（Prometheus+Grafana）

**数据一致性：**
- 分布式事务（Seata）
- 最终一致性（Saga模式）
- 补偿机制设计

20:33
"那就是你们留了一个内部访问的接口去做这个事务的回滚，在这个FPS（这里应该是面试官口误了，应为CRM或者ICSP）消息有阻塞的时候。那后面会有审计的风险"
A: 您提到的审计风险确实是个重要问题，我们有完善的应对机制：

**审计安全设计：**
1. **操作日志记录**：所有回滚操作都有详细的审计日志
2. **权限控制**：回滚接口只允许特定服务调用，有严格的认证授权
3. **操作追踪**：记录操作人、操作时间、操作原因、影响范围

**风险控制措施：**
1. **双重确认**：重要回滚操作需要多人审批
2. **时间窗口限制**：回滚操作有时效性，超时自动失效
3. **影响范围评估**：回滚前评估对其他业务的影响
4. **实时监控**：异常回滚操作实时告警

**技术实现：**
```java
@RestController
@PreAuthorize("hasRole('SYSTEM')")
public class CompensationController {
    
    @PostMapping("/compensate")
    @AuditLog(operation = "TRANSACTION_ROLLBACK")
    public Result compensate(@RequestBody CompensationRequest request) {
        // 1. 验证请求合法性
        validateRequest(request);
        // 2. 记录审计日志
        auditService.log(request);
        // 3. 执行补偿操作
        return compensationService.execute(request);
    }
}
```

**合规保障：**
- 所有操作可追溯、可审计
- 定期审计报告和风险评估
- 符合SOX、等保等合规要求

16:28
"我指的是多地，就是一个系统多地部署"（我说了一堆机房，双活）
A: 理解，您说的是多地域部署的分布式架构。我们实施过同城双活和异地多活：

**同城双活架构：**
- 两个机房部署相同的应用服务
- 数据库主从复制，读写分离
- 通过负载均衡器分流流量
- 故障时自动切换到备用机房

**异地多活架构：**
- 多个地域部署完整的服务栈
- 数据库采用多主复制或分片策略
- CDN就近访问，降低延迟
- 通过DNS智能解析实现就近路由

**关键技术点：**
1. **数据同步**：使用Canal或DTS实现实时数据同步
2. **流量调度**：基于地理位置的智能路由
3. **一致性保证**：最终一致性模型，避免强一致性的性能损耗
4. **故障切换**：自动化的故障检测和流量切换机制

**挑战与解决：**
- 网络延迟：通过缓存和异步处理优化
- 数据冲突：设计合理的冲突解决策略
- 运维复杂度：标准化部署和监控体系

17:51
"前面这一段我不太关注，主要是可能你几个业务系统之间，假设你做了分布式部署，你这个业务系统之间的事务一致性，你当时怎么管理的？"
A: 分布式事务一致性是个核心问题，我们采用了多种策略：

**强一致性方案：**
1. **两阶段提交（2PC）**：使用Seata AT模式，自动管理分布式事务
2. **三阶段提交（3PC）**：在关键业务场景使用，减少阻塞时间

**最终一致性方案：**
1. **Saga模式**：将长事务拆分为多个本地事务，每个事务都有对应的补偿操作
2. **TCC模式**：Try-Confirm-Cancel三阶段，业务层面保证一致性
3. **消息队列**：通过可靠消息最终一致性，确保消息投递和消费

**具体实现：**
```java
// Saga模式示例
@SagaOrchestrationStart
public void processOrder(OrderEvent event) {
    // 1. 扣减库存
    inventoryService.reduceStock(event);
    // 2. 扣减余额
    accountService.deductBalance(event);
    // 3. 创建订单
    orderService.createOrder(event);
}

// 补偿操作
@SagaOrchestrationCancel
public void cancelOrder(OrderEvent event) {
    orderService.cancelOrder(event);
    accountService.refundBalance(event);
    inventoryService.restoreStock(event);
}
```

**选择策略：**
- 金融场景：强一致性（2PC/3PC）
- 电商场景：最终一致性（Saga/TCC）
- 日志场景：异步消息

21:54
"我问一下你啊，我看你之前一直都在做开发，现在到思特沃克做顾问。你觉得在顾问跟开发这块，你自己从能力上从职责上面，有没有什么大的区别啊？"
A: 这是个很好的问题，从开发到顾问确实有很大的转变：

**能力要求的变化：**

**技术深度 -> 技术广度**
- 开发：专精某个技术栈，深入底层实现
- 顾问：需要了解多种技术方案，能够做技术选型和架构决策

**执行能力 -> 决策能力**
- 开发：按需求实现功能，关注代码质量和性能
- 顾问：需要分析业务需求，设计整体解决方案

**个人产出 -> 团队赋能**
- 开发：个人编码效率和质量
- 顾问：通过指导和培训提升整个团队的能力

**职责变化：**

**从"How"到"What"和"Why"**
- 开发关注如何实现
- 顾问关注做什么、为什么这样做

**沟通对象的变化**
- 开发：主要与技术团队沟通
- 顾问：需要与业务方、管理层、技术团队多方沟通

**价值体现**
- 开发：通过代码创造价值
- 顾问：通过方案设计和团队提升创造价值

**个人感受：**
这个转变让我从关注局部优化转向关注整体效果，从技术实现转向业务价值，虽然挑战更大，但也更有成就感。

24:19
"我看你对CRM有一些了解是吧？你现在主要是做了一个商机管理、客户的管理，CRM 销售服务后面有没有涉及到啊？"
A: 是的，我们的CRM系统是一个完整的客户生命周期管理平台：

**核心模块：**

**销售管理模块：**
- 线索管理：从市场活动获取的潜在客户信息
- 商机管理：销售漏斗、阶段推进、赢单分析
- 客户管理：360度客户视图、客户分级、关系维护
- 合同管理：合同生成、审批流程、执行跟踪

**服务管理模块：**
- 工单系统：客户问题受理、分派、跟踪、解决
- 知识库：常见问题、解决方案、最佳实践
- SLA管理：服务等级协议、响应时间监控
- 客户满意度：服务评价、NPS调研

**技术架构特点：**
1. **微服务架构**：销售、服务、客户等独立服务
2. **事件驱动**：客户状态变更通过事件同步
3. **工作流引擎**：支持复杂的业务流程定制
4. **BI集成**：实时报表和数据分析

**业务价值：**
- 销售效率提升30%
- 客户满意度提升到95%
- 服务响应时间缩短50%

我们特别注重售前售后的一体化，确保客户体验的连续性。

28:40
"我说一些常见的安全攻击，的了不了解？"
A: 当然了解，Web安全是系统设计的重要考虑因素：

**常见攻击类型：**

**1. SQL注入**
- 原理：恶意SQL代码注入到应用查询中
- 防护：参数化查询、输入验证、最小权限原则

**2. XSS（跨站脚本攻击）**
- 原理：注入恶意脚本到网页中
- 防护：输出编码、CSP策略、HttpOnly Cookie

**3. CSRF（跨站请求伪造）**
- 原理：利用用户身份执行非预期操作
- 防护：CSRF Token、SameSite Cookie、Referer验证

**4. 文件上传漏洞**
- 原理：上传恶意文件执行代码
- 防护：文件类型检查、路径限制、病毒扫描

**5. 权限提升**
- 原理：获取超出授权的系统权限
- 防护：最小权限原则、权限矩阵、定期审计

**6. DDoS攻击**
- 原理：大量请求导致服务不可用
- 防护：CDN、限流、黑名单、弹性扩容

**安全设计原则：**
- 纵深防御：多层安全控制
- 最小权限：只给必要的权限
- 安全编码：从开发阶段就考虑安全
- 持续监控：实时检测和响应

我们在项目中都会进行安全评估和渗透测试，确保系统安全性。
