<div class="Card AnswerCard css-0"><div class="QuestionAnswer-content" tabindex="0"><div><div class="ContentItem AnswerItem" data-zop="{&quot;authorName&quot;:&quot;AI编程指北&quot;,&quot;itemId&quot;:&quot;1936175709690245208&quot;,&quot;title&quot;:&quot;Spring IoC有什么好处呢？&quot;,&quot;type&quot;:&quot;answer&quot;}" name="1936175709690245208" itemprop="mainEntityOfPage" itemtype="http://schema.org/Answer" itemscope="" data-za-detail-view-path-module="AnswerItem" data-za-extra-module="{&quot;card&quot;:{&quot;has_image&quot;:false,&quot;has_video&quot;:false,&quot;content&quot;:{&quot;type&quot;:&quot;Answer&quot;,&quot;token&quot;:&quot;1936175709690245208&quot;,&quot;upvote_num&quot;:1,&quot;comment_num&quot;:0,&quot;publish_timestamp&quot;:null,&quot;parent_token&quot;:&quot;23277575&quot;,&quot;author_member_hash_id&quot;:&quot;cea6807762b62eb8510b87f7fe47f51e&quot;}}}"><div class="ContentItem-meta"><div class="AuthorInfo AnswerItem-authorInfo AnswerItem-authorInfo--related" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><div class="AuthorInfo"><meta itemprop="name" content="AI编程指北"><meta itemprop="image" content="https://picx.zhimg.com/v2-8b21e673466aab106cb4dedc50876d67_l.jpg?source=2c26e567"><meta itemprop="url" content="https://www.zhihu.com/people/elvalee-82"><meta itemprop="zhihu:followerCount"><span class="UserLink AuthorInfo-avatarWrapper"><div class="css-1gomreu"><a href="//www.zhihu.com/people/elvalee-82" target="_blank" class="UserLink-link" data-za-detail-view-element_name="User"><img class="Avatar AuthorInfo-avatar css-1hx3fyn" src="https://picx.zhimg.com/v2-8b21e673466aab106cb4dedc50876d67_l.jpg?source=2c26e567" srcset="https://picx.zhimg.com/v2-8b21e673466aab106cb4dedc50876d67_l.jpg?source=2c26e567 2x" alt="AI编程指北"></a></div></span><div class="AuthorInfo-content"><div class="AuthorInfo-head"><span class="UserLink AuthorInfo-name"><div class="css-1gomreu"><a href="//www.zhihu.com/people/elvalee-82" target="_blank" class="UserLink-link" data-za-detail-view-element_name="User">AI编程指北</a></div></span></div><div class="AuthorInfo-detail"><div class="AuthorInfo-badge"><div class="ztext AuthorInfo-badgeText css-14ur8a8">20Y+大厂架构师, 工具提效实战, 硅脑探索和记录</div></div></div></div></div><button type="button" class="Button FollowButton css-upmq18 FEfUrdfMIKpQDJDqkjte Button--secondary Button--blue E211w_M7Hzs0GMB7BEyA JmYzaky7MEPMFcJDLNMG"><span style="display: inline-flex; align-items: center;">​<svg width="1.2em" height="1.2em" viewBox="0 0 24 24" class="ZDI ZDI--PlusFill24" fill="currentColor"><path fill-rule="evenodd" d="M13.25 3.25a1.25 1.25 0 1 0-2.5 0v7.5h-7.5a1.25 1.25 0 1 0 0 2.5h7.5v7.5a1.25 1.25 0 1 0 2.5 0v-7.5h7.5a1.25 1.25 0 0 0 0-2.5h-7.5v-7.5Z" clip-rule="evenodd"></path></svg></span> 关注</button><div class="css-124ezq8"></div></div><div><div class="css-dvccr2"><div class="css-1lr85n">1 人赞同了该回答</div><svg width="14px" height="14px" viewBox="0 0 16 16" class="ZDI ZDI--ArrowRight16 css-z4ujak" fill="currentColor"><path fill-rule="evenodd" d="M6.252 2.328a.75.75 0 0 1 1.04.213l3.334 5.05a.75.75 0 0 1 0 .826L7.292 13.46a.75.75 0 0 1-1.251-.828L9.1 8.004 6.04 3.367a.75.75 0 0 1 .212-1.039Z" clip-rule="evenodd"></path></svg></div></div><span class="css-z4ujak"></span></div><meta itemprop="image"><meta itemprop="upvoteCount" content="1"><meta itemprop="url" content="https://www.zhihu.com/question/23277575/answer/1936175709690245208"><meta itemprop="dateCreated" content="2025-08-05T13:24:21.000Z"><meta itemprop="dateModified" content="2025-08-05T13:24:21.000Z"><meta itemprop="commentCount" content="0"><div class="RichContent RichContent--unescapable"><span><div class="RichContent-inner"><div class="css-376mun"><span id="content"><span class="RichText ztext CopyrightRichText-richText css-oqi8p3" options="[object Object]" itemprop="text"><h2 data-first-child=""><span><a class="RichContent-EntityWord css-b7erz1" data-za-not-track-link="true" data-paste-text="true" href="https://zhida.zhihu.com/search?content_id=740688980&amp;content_type=Answer&amp;match_order=1&amp;q=Spring+IoC&amp;zhida_source=entity" target="_blank">Spring IoC<svg width="10px" height="10px" viewBox="0 0 16 16" class="ZDI ZDI--FourPointedStar16 css-1dvsrp" fill="currentColor"><path d="m5.068 9.267-3.08-.77a.512.512 0 0 1 0-.994l3.08-.77a2.289 2.289 0 0 0 1.665-1.665l.77-3.08a.512.512 0 0 1 .994 0l.77 3.08c.205.82.845 1.46 1.665 1.665l3.08.77a.512.512 0 0 1 0 .994l-3.08.77a2.29 2.29 0 0 0-1.665 1.665l-.77 3.08a.512.512 0 0 1-.994 0l-.77-3.08a2.289 2.289 0 0 0-1.665-1.665Z"></path></svg></a></span></h2><h3>IoC 概念</h3><h3>IoC 是什么</h3><p data-pid="hqrzCsP6"><b>IoC，是 Inversion of Control 的缩写，即控制反转。</b>它还有一个别名叫<b><span><a class="RichContent-EntityWord css-b7erz1" data-za-not-track-link="true" data-paste-text="true" href="https://zhida.zhihu.com/search?content_id=740688980&amp;content_type=Answer&amp;match_order=1&amp;q=%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5&amp;zhida_source=entity" target="_blank">依赖注入<svg width="10px" height="10px" viewBox="0 0 16 16" class="ZDI ZDI--FourPointedStar16 css-1dvsrp" fill="currentColor"><path d="m5.068 9.267-3.08-.77a.512.512 0 0 1 0-.994l3.08-.77a2.289 2.289 0 0 0 1.665-1.665l.77-3.08a.512.512 0 0 1 .994 0l.77 3.08c.205.82.845 1.46 1.665 1.665l3.08.77a.512.512 0 0 1 0 .994l-3.08.77a2.29 2.29 0 0 0-1.665 1.665l-.77 3.08a.512.512 0 0 1-.994 0l-.77-3.08a2.289 2.289 0 0 0-1.665-1.665Z"></path></svg></a></span></b>（Dependency Injection）有些资料也称依赖注入是 IOC 的一种常见方式。</p><p data-pid="XR3YL-xW">IoC 不是什么技术，而是一种设计思想。在 Java 开发中，IoC 意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解 Ioc 呢？理解 Ioc 的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p><ul><li data-pid="iAdxvtAO"><b>谁控制谁，控制什么：</b>传统 JavaSE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是由专门一个容器来创建这些对象，即由 IoC 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</li><li data-pid="cY7vOuui"><b>为何是反转，哪些方面反转了：</b>有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="nd77uVka">当有了 IoC/DI 的容器后，在客户端类中不再主动去创建这些对象了，如图 2-2 所示:</p><p class="ztext-empty-paragraph"><br></p><h3>IoC 能做什么</h3><p data-pid="R0D5v6Ly">IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了 IoC 容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p><p data-pid="946q0r9u">其实 IoC 对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在 IoC/DI 思想中，应用程序就变成被动的了，被动的等待 IoC 容器来创建并注入它所需要的资源了。</p><p data-pid="lH4YXCDk">IoC 很好的体现了面向对象设计法则之一—— 好莱坞法则：“Don『t call us,we will call you”；即由 IoC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h3>依赖注入</h3><p data-pid="pZUTx2SB">DI，是 <b>Dependency Injection</b> 的缩写，即依赖注入。</p><p data-pid="AEmEJriG">依赖注入是 IoC 的最常见形式。</p><p data-pid="waoBJplY">容器全权负责的组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造函数传递给需要的对象。</p><p data-pid="UwzlMNHZ">DI 是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><p data-pid="ofAuvNRD">理解 DI 的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><ul><li data-pid="1VIulKcm"><b>谁依赖于谁：</b>当然是应用程序依赖于 IoC 容器；</li><li data-pid="t4aaHeD2"><b>为什么需要依赖：</b>应用程序需要 IoC 容器来提供对象需要的外部资源；</li><li data-pid="Es-mF7bv"><b>谁注入谁：</b>很明显是 IoC 容器注入应用程序某个对象，应用程序依赖的对象；</li><li data-pid="T_FYBNil"><b>注入了什么</b>：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li></ul><h3>IoC 和 DI</h3><p data-pid="kIMGYRh_">其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年大师级人物 Martin Fowler 又给出了一个新的名字：“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。</p><blockquote data-pid="rYg6Zm6C"> 注：如果想要更加深入的了解 IoC 和 DI，请参考大师级人物 Martin Fowler 的一篇经典文章 <a href="https://link.zhihu.com/?target=http%3A//www.martinfowler.com/articles/injection.html" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Inversion of Control Containers and the Dependency Injection pattern</a> 。</blockquote><h3>IoC 容器</h3><p data-pid="OqaK2EGi">IoC 容器就是具有依赖注入功能的容器。IoC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中 new 相关的对象，应用程序由 IoC 容器进行组装。在 Spring 中 BeanFactory 是 IoC 容器的实际代表者。</p><p data-pid="l9ZArd6k">Spring IoC 容器如何知道哪些是它管理的对象呢？这就需要配置文件，Spring IoC 容器通过读取配置文件中的配置元数据，通过元数据对应用中的各个对象进行实例化及装配。一般使用基于 xml 配置文件进行配置元数据，而且 Spring 与配置文件完全解耦的，可以使用其他任何可能的方式进行配置元数据，比如注解、基于 Java 文件的、基于属性文件的配置都可以</p><p data-pid="u2DIssjQ">那 Spring IoC 容器管理的对象叫什么呢？</p><h3>Bean</h3><p data-pid="Dy55DoJw">JavaBean 是一种 Java 语言写成的可重用组件。为写成 JavaBean，类必须是具体的和公共的，并且具有<b>无参数的构造器</b>。JavaBean 通过提供符合一致性设计模式的公共方法（getter / setter 方法）将内部域暴露成员属性。众所周知，属性名称符合这种模式，其他 Java 类可以通过自省机制发现和操作这些 JavaBean 的属性。</p><p data-pid="MKinK5CH">一个 javaBean 由三部分组成：<b>属性、方法、事件</b></p><p data-pid="bWtnYHu5">JavaBean 的任务就是: “Write once, run anywhere, reuse everywhere”，即“一次性编写，任何地方执行,任何地方重用”。</p><p data-pid="zpHwsYSk">由 IoC 容器管理的那些组成你应用程序的对象我们就叫它 Bean。Bean 就是由 Spring 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。</p><h3>IoC 容器</h3><h3>核心接口</h3><p data-pid="IqKjor_j"><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 是 IoC 容器的基础。</p><p data-pid="lQeGFtPE">在 Spring 中，有两种 IoC 容器：<code>BeanFactory</code> 和 <code>ApplicationContext</code>。</p><ul><li data-pid="8oWrQTtB"><code>BeanFactory</code>：Spring 实例化、配置和管理对象的最基本接口。</li><li data-pid="PjWHHT0L"><code>ApplicationContext</code>：BeanFactory 的子接口。它还扩展了其他一些接口，以支持更丰富的功能，如：国际化、访问资源、事件机制、更方便的支持 AOP、在 web 应用中指定应用层上下文等。</li></ul><p data-pid="7vD4hEbT">实际开发中，更推荐使用 <code>ApplicationContext</code> 作为 IoC 容器，因为它的功能远多于 <code>FactoryBean</code>。</p><p data-pid="L9cYm4EQ">常见 <code>ApplicationContext</code> 实现：</p><ul><li data-pid="xg-w4pC6"><b>ClassPathXmlApplicationContext</b>：<code>ApplicationContext</code> 的实现，从 classpath 获取配置文件；</li></ul><div class="highlight"><pre><code class="language-java"><span class="n">BeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="err">「</span><span class="n">classpath</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">);</span></code></pre></div><ul><li data-pid="g6CJTASl"><b>FileSystemXmlApplicationContext</b>：<code>ApplicationContext</code> 的实现，从文件系统获取配置文件。</li></ul><div class="highlight"><pre><code class="language-java"><span class="n">BeanFactory</span> <span class="n">beanFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileSystemXmlApplicationContext</span><span class="o">(</span><span class="err">「</span><span class="n">fileSystemConfig</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">);</span></code></pre></div><h3>IoC 容器工作步骤</h3><p data-pid="MlwAxBx5">使用 IoC 容器可分为三步骤：</p><ol><li data-pid="OKghK582">配置元数据：需要配置一些元数据来告诉 Spring，你希望容器如何工作，具体来说，就是如何去初始化、配置、管理 JavaBean 对象。</li></ol><p data-pid="7JEO8z3x">2)  实例化容器：由 IoC 容器解析配置的元数据。IoC 容器的 Bean Reader 读取并解析配置文件，根据定义生成 BeanDefinition 配置元数据对象，IoC 容器根据 BeanDefinition 进行实例化、配置及组装 Bean。</p><ol><li data-pid="A8hupudU">使用容器：由客户端实例化容器，获取需要的 Bean。</li></ol><h3>配置元数据</h3><blockquote data-pid="rRJSwAqJ"><b>元数据（Metadata）</b> 又称中介数据、中继数据，为描述数据的数据（data about data），主要是描述数据属性（property）的信息。</blockquote><p data-pid="3i51HEKJ">配置元数据的方式：</p><ul><li data-pid="V2pt167q"><b>基于 xml 配置</b>：Spring 的传统配置方式。在 <code>&lt;beans&gt;</code> 标签中配置元数据内容。</li></ul><p data-pid="LSeHYio6">缺点是当 JavaBean 过多时，产生的配置文件足以让你眼花缭乱。</p><ul><li data-pid="W2gMoWqc"><b>基于注解配置</b>：Spring2.5 引入。可以大大简化你的配置。<br> </li><li data-pid="2guTmv0R"><b>基于 Java 配置</b>：可以使用 Java 类来定义 JavaBean 。<br> </li></ul><p data-pid="EyDu9Ui3">为了使用这个新特性，需要用到 <code>@Configuration</code> 、<code>@Bean</code> 、<code>@Import</code> 和 <code>@DependsOn</code> 注解。</p><h3>Bean 概述</h3><p data-pid="_VsPV0cc">一个 Spring 容器管理一个或多个 bean。 这些 bean 根据你配置的元数据（比如 xml 形式）来创建。 Spring IoC 容器本身，并不能识别你配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——BeanDefinition 对象。</p><h3>命名 Bean</h3><p data-pid="oxKLoWF0">指定 id 和 name 属性不是必须的。 Spring 中，并非一定要指定 id 和 name 属性。实际上，Spring 会自动为其分配一个特殊名。 如果你需要引用声明的 bean，这时你才需要一个标识。官方推荐驼峰命名法来命名。</p><h3>支持别名</h3><p data-pid="Z4iLZn1w">可能存在这样的场景，不同系统中对于同一 bean 的命名方式不一样。 为了适配，Spring 支持 <code>&lt;alias&gt;</code> 为 bean 添加别名的功能。</p><div class="highlight"><pre><code class="language-xml"><span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">「subsystemA-dataSource」</span> <span class="na">alias=</span><span class="s">「subsystemB-dataSource」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;alias</span> <span class="na">name=</span><span class="s">「subsystemA-dataSource」</span> <span class="na">alias=</span><span class="s">「myApp-dataSource」</span> <span class="nt">/&gt;</span></code></pre></div><h3>实例化 Bean</h3><p data-pid="f5tVLUr8"><b>构造器方式</b></p><div class="highlight"><pre><code class="language-xml"><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「exampleBean」</span> <span class="na">class=</span><span class="s">「examples.ExampleBean」/</span><span class="nt">&gt;</span></code></pre></div><p data-pid="iWgMUCxk"><b>静态工厂方法</b></p><h3>依赖</h3><p data-pid="PAvqHJbN">依赖注入 依赖注入有两种主要方式：</p><ul><li data-pid="gcLOIOHi">构造器注入</li><li data-pid="-WtYjqkX">Setter 注入   构造器注入有可能出现循环注入的错误。如：</li></ul><div class="highlight"><pre><code class="language-java"><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="n">B</span> <span class="n">b</span><span class="o">){}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">B</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">){}</span>
<span class="o">}</span></code></pre></div><p data-pid="XCOCs9OI"><b>依赖和配置细节</b> 使用 depends-on Lazy-initialized Bean 自动装配 方法注入</p><h3>IoC 容器配置</h3><p data-pid="J2--pbqU">IoC 容器的配置有三种方式：</p><ul><li data-pid="S8Bu8239">基于 xml 配置</li><li data-pid="-7mJythB">基于注解配置</li><li data-pid="RhwlOPY4">基于 Java 配置</li></ul><p data-pid="zCubRup2">作为 Spring 传统的配置方式，xml 配置方式一般为大家所熟知。</p><p data-pid="_xxdeAdv">如果厌倦了 xml 配置，Spring 也提供了注解配置方式或 Java 配置方式来简化配置。</p><p data-pid="XQg3n1wg"><b>本文，将对 Java 配置 IoC 容器做详细的介绍。</b></p><h3>Xml 配置</h3><div class="highlight"><pre><code class="language-xml"><span class="cp">&lt;?xml version=「1.0」 encoding=「UTF-8」?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">「HTTP://www.springframework.org/schema/beans」</span>
       <span class="na">xmlns:xsi=</span><span class="s">「HTTP://www.w3.org/2001/XMLSchema-instance」</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">「HTTP://www.springframework.org/schema/beans</span>
         <span class="err">HTTP://www.springframework.org/schema/beans/spring-beans.xsd」</span><span class="nt">&gt;</span>
  <span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">「resource1.xml」</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「bean1」</span> <span class="na">class=</span><span class="s">「」</span><span class="nt">&gt;&lt;/bean&gt;</span>
  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「bean2」</span> <span class="na">class=</span><span class="s">「」</span><span class="nt">&gt;&lt;/bean&gt;</span>
  <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">「bean2」</span> <span class="na">class=</span><span class="s">「」</span><span class="nt">&gt;&lt;/bean&gt;</span>

  <span class="nt">&lt;alias</span> <span class="na">alias=</span><span class="s">「bean3」</span> <span class="na">name=</span><span class="s">「bean2」/</span><span class="nt">&gt;</span>
  <span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">「resource2.xml」</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span></code></pre></div><p data-pid="N1ygfkW9">标签说明：</p><ul><li data-pid="z5qmH2rK"><code>&lt;beans&gt;</code> 是 Spring 配置文件的根节点。</li><li data-pid="SkYjyxF1"><code>&lt;bean&gt;</code> 用来定义一个 JavaBean。<code>id</code> 属性是它的标识，在文件中必须唯一；<code>class</code> 属性是它关联的类。</li><li data-pid="Z9VD868T"><code>&lt;alias&gt;</code> 用来定义 Bean 的别名。</li><li data-pid="sBPrjDB2"><code>&lt;import&gt;</code> 用来导入其他配置文件的 Bean 定义。这是为了加载多个配置文件，当然也可以把这些配置文件构造为一个数组（new String[] {“config1.xml”, “config2.xml}）传给 <code>ApplicationContext</code> 实现类进行加载多个配置文件，那一个更适合由用户决定；这两种方式都是通过调用 Bean Definition Reader 读取 Bean 定义，内部实现没有任何区别。<code>&lt;import&gt;</code> 标签可以放在 <code>&lt;beans&gt;</code> 下的任何位置，没有顺序关系。</li></ul><h3>实例化容器</h3><p data-pid="UReDUZVh">实例化容器的过程： 定位资源（XML 配置文件） 读取配置信息(Resource) 转化为 Spring 可识别的数据形式（BeanDefinition）</p><div class="highlight"><pre><code class="language-java"><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="o">{</span><span class="err">「</span><span class="n">services</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">,</span> <span class="err">「</span><span class="n">daos</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">});</span></code></pre></div><p data-pid="Rjhunc7a">组合 xml 配置文件 配置的 Bean 功能各不相同，都放在一个 xml 文件中，不便管理。 Java 设计模式讲究职责单一原则。配置其实也是如此，功能不同的 JavaBean 应该被组织在不同的 xml 文件中。然后使用 import 标签把它们统一导入。</p><div class="highlight"><pre><code class="language-xml"><span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">「classpath:spring/applicationContext.xml」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;import</span> <span class="na">resource=</span><span class="s">「/WEB-INF/spring/service.xml」/</span><span class="nt">&gt;</span></code></pre></div><h3>使用容器</h3><p data-pid="HagOh0sH">使用容器的方式就是通过 <code>getBean </code>获取 IoC 容器中的 JavaBean。 Spring 也有其他方法去获得 JavaBean，但是 Spring 并不推荐其他方式。</p><div class="highlight"><pre><code class="language-java"><span class="c1">// create and configure beans
</span><span class="c1"></span><span class="n">ApplicationContext</span> <span class="n">context</span> <span class="o">=</span>
<span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[]</span> <span class="o">{</span><span class="err">「</span><span class="n">services</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">,</span> <span class="err">「</span><span class="n">daos</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">});</span>
<span class="c1">// retrieve configured instance
</span><span class="c1"></span><span class="n">PetStoreService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="err">「</span><span class="n">petStore</span><span class="err">」</span><span class="o">,</span> <span class="n">PetStoreService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// use configured instance
</span><span class="c1"></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">userList</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">getUsernameList</span><span class="o">();</span></code></pre></div><h3>注解配置</h3><p data-pid="AQNpKoVa">Spring2.5 引入了注解。 于是，一个问题产生了：<b>使用注解方式注入 JavaBean 是不是一定完爆 xml 方式？</b> 未必。正所谓，仁者见仁智者见智。任何事物都有其优缺点，看你如何取舍。来看看注解的优缺点： <b>优点</b>：大大减少了配置，并且可以使配置更加精细——类，方法，字段都可以用注解去标记。 <b>缺点</b>：使用注解，不可避免产生了侵入式编程，也产生了一些问题。</p><ul><li data-pid="AM_vRO79"> 你需要将注解加入你的源码并编译它；<br> </li><li data-pid="cXraspVK"> 注解往往比较分散，不易管控。<br> </li></ul><blockquote data-pid="iHEjGJfQ"> 注：spring 中，先进行注解注入，然后才是 xml 注入，因此如果注入的目标相同，后者会覆盖前者。</blockquote><h3>启动注解</h3><p data-pid="c0_CpFYq">Spring 默认是不启用注解的。如果想使用注解，需要先在 xml 中启动注解。 启动方式：在 xml 中加入一个标签，很简单吧。</p><div class="highlight"><pre><code class="language-xml"><span class="nt">&lt;context:annotation-config/&gt;</span></code></pre></div><blockquote data-pid="MXjCD3ib"> 注：<code>&lt;context:annotation-config/&gt;</code> 只会检索定义它的上下文。什么意思呢？就是说，如果你 为 DispatcherServlet 指定了一个 <code>WebApplicationContext</code>，那么它只在 controller 中查找<code>@Autowired </code>注解，而不会检查其它的路径。</blockquote><h3>Spring 注解</h3><ul><li data-pid="LS0qj3oV"><b><code>@Required</code></b></li></ul><p data-pid="psHj26YJ"><code>@Required</code> 注解只能用于修饰 bean 属性的 setter 方法。受影响的 bean 属性必须在配置时被填充在 xml 配置文件中，否则容器将抛出 <code>BeanInitializationException</code>。</p><div class="highlight"><pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationRequired</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">sex</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="o">/**</span>
     <span class="o">*</span> <span class="nd">@Required</span> <span class="n">注解用于</span> <span class="n">bean</span> <span class="n">属性的</span> <span class="n">setter</span> <span class="n">方法并且它指示</span><span class="err">，</span><span class="n">受影响的</span> <span class="n">bean</span> <span class="n">属性必须在配置时被填充在</span> <span class="n">xml</span> <span class="n">配置文件中</span><span class="err">，</span>
     <span class="o">*</span>           <span class="n">否则容器将抛出</span> <span class="n">BeanInitializationException</span><span class="err">。</span>
     <span class="o">*</span>
    <span class="nd">@Required</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getSex</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sex</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSex</span><span class="o">(</span><span class="n">String</span> <span class="n">sex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sex</span> <span class="o">=</span> <span class="n">sex</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><ul><li data-pid="aT0xUkiv"><b><code>@Autowired</code></b></li></ul><p data-pid="Ca2O7JzQ"><code>@Autowired </code>注解可用于修饰属性、setter 方法、构造方法。</p><blockquote data-pid="WynPWpVg"> 注：<code>@Autowired </code>注解也可用于修饰构造方法，但如果类中只有默认构造方法，则没有必要。如果有多个构造器，至少应该修饰一个，来告诉容器哪一个必须使用。</blockquote><p data-pid="W6UUWOLD">可以使用 JSR330 的注解<code>@Inject </code>来替代<code>@Autowired</code>。</p><p data-pid="whauXPH4"><b><i>范例</i></b></p><div class="highlight"><pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationAutowired</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">AnnotationRequired</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="n">Apple</span> <span class="n">fieldA</span><span class="o">;</span>

    <span class="kd">private</span> <span class="n">Banana</span> <span class="n">field</span>

    <span class="kd">private</span> <span class="n">Orange</span> <span class="n">field</span>

    <span class="kd">public</span> <span class="n">Apple</span> <span class="nf">getFieldA</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fieldA</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFieldA</span><span class="o">(</span><span class="n">Apple</span> <span class="n">fieldA</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fieldA</span> <span class="o">=</span> <span class="n">fieldA</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Banana</span> <span class="nf">getFieldB</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fieldB</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFieldB</span><span class="o">(</span><span class="n">Banana</span> <span class="n">fieldB</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fieldB</span> <span class="o">=</span> <span class="n">fieldB</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Orange</span> <span class="nf">getFieldC</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fieldC</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFieldC</span><span class="o">(</span><span class="n">Orange</span> <span class="n">fieldC</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fieldC</span> <span class="o">=</span> <span class="n">fieldC</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">AnnotationAutowired</span><span class="o">()</span> <span class="o">{}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="nf">AnnotationAutowired</span><span class="o">(</span><span class="n">Orange</span> <span class="n">fieldC</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fieldC</span> <span class="o">=</span> <span class="n">fieldC</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">AbstractApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span>
                        <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="err">「</span><span class="n">spring</span><span class="o">/</span><span class="n">spring</span><span class="o">-</span><span class="n">annotation</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">);</span>

        <span class="n">AnnotationAutowired</span> <span class="n">annotationAutowired</span> <span class="o">=</span>
                        <span class="o">(</span><span class="n">AnnotationAutowired</span><span class="o">)</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="err">「</span><span class="n">annotationAutowired</span><span class="err">」</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">fieldA</span><span class="o">:</span> <span class="o">{},</span> <span class="n">fieldB</span><span class="o">:{},</span> <span class="n">fieldC</span><span class="o">:{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationAutowired</span><span class="o">.</span><span class="na">getFieldA</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span>
                        <span class="n">annotationAutowired</span><span class="o">.</span><span class="na">getFieldB</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span>
                        <span class="n">annotationAutowired</span><span class="o">.</span><span class="na">getFieldC</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><p data-pid="HBaVyFCq">xml 中的配置</p><div class="highlight"><pre><code class="language-xml"><span class="c">&lt;!-- 测试@Autowired --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「apple」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.Apple」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「potato」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.Banana」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「tomato」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.Orange」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「annotationAutowired」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.AnnotationAutowired」/</span><span class="nt">&gt;</span></code></pre></div><ul><li data-pid="8Dtey3w8"><b><code>@Qualifier</code></b></li></ul><p data-pid="ZG6YCIwD">在<code>@Autowired </code>注解中，提到了如果发现有多个候选的 bean 都符合修饰类型，Spring 就会抓瞎了。</p><p data-pid="WYESv_gt">那么，如何解决这个问题。</p><p data-pid="X2x--wsY">可以通过<code>@Qualifier </code>指定 bean 名称来锁定真正需要的那个 bean。</p><p data-pid="1pu43I6x"><b><i>范例</i></b></p><div class="highlight"><pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationQualifier</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">AnnotationQualifier</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Autowired</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="err">「</span><span class="n">dog</span><span class="err">」</span><span class="o">)</span> <span class="cm">/** 去除这行，会报异常 */</span>
    <span class="n">Animal</span> <span class="n">dog</span><span class="o">;</span>

    <span class="n">Animal</span> <span class="n">cat</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Animal</span> <span class="nf">getDog</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">dog</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDog</span><span class="o">(</span><span class="n">Animal</span> <span class="n">dog</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dog</span> <span class="o">=</span> <span class="n">dog</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Animal</span> <span class="nf">getCat</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">cat</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCat</span><span class="o">(</span><span class="nd">@Qualifier</span><span class="o">(</span><span class="err">「</span><span class="n">cat</span><span class="err">」</span><span class="o">)</span> <span class="n">Animal</span> <span class="n">cat</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cat</span> <span class="o">=</span> <span class="n">cat</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">AbstractApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span>
                <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="err">「</span><span class="n">spring</span><span class="o">/</span><span class="n">spring</span><span class="o">-</span><span class="n">annotation</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">);</span>

        <span class="n">AnnotationQualifier</span> <span class="n">annotationQualifier</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">AnnotationQualifier</span><span class="o">)</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="err">「</span><span class="n">annotationQualifier</span><span class="err">」</span><span class="o">);</span>

        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">Dog</span> <span class="n">name</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationQualifier</span><span class="o">.</span><span class="na">getDog</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">Cat</span> <span class="n">name</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationQualifier</span><span class="o">.</span><span class="na">getCat</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="err">「</span><span class="n">狗</span><span class="err">」</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="err">「</span><span class="n">猫</span><span class="err">」</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><p data-pid="XTCt8s8V">xml 中的配置</p><div class="highlight"><pre><code class="language-xml"><span class="c">&lt;!-- 测试@Qualifier --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「dog」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.Dog」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「cat」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.Cat」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「annotationQualifier」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.AnnotationQualifier」/</span><span class="nt">&gt;</span></code></pre></div><h3>JSR 250 注解</h3><p data-pid="LVOyaPno">@Resource</p><p data-pid="l7jGyC25">Spring 支持 JSP250 规定的注解<code>@Resource</code>。这个注解根据指定的名称来注入 bean。</p><p data-pid="dTXugJli">如果没有为<code>@Resource </code>指定名称，它会像<code>@Autowired </code>一样按照类型去寻找匹配。</p><p data-pid="H1eTL6_P">在 Spring 中，由 <code>CommonAnnotationBeanPostProcessor </code>来处理<code>@Resource </code>注解。</p><p data-pid="xgn7F0XI"><b><i>范例</i></b></p><div class="highlight"><pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationResource</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">AnnotationResource</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Resource</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="err">「</span><span class="n">flower</span><span class="err">」</span><span class="o">)</span>
    <span class="n">Plant</span> <span class="n">flower</span><span class="o">;</span>

    <span class="nd">@Resource</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="err">「</span><span class="n">tree</span><span class="err">」</span><span class="o">)</span>
    <span class="n">Plant</span> <span class="n">tree</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Plant</span> <span class="nf">getFlower</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">flower</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFlower</span><span class="o">(</span><span class="n">Plant</span> <span class="n">flower</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">flower</span> <span class="o">=</span> <span class="n">flower</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Plant</span> <span class="nf">getTree</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">tree</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTree</span><span class="o">(</span><span class="n">Plant</span> <span class="n">tree</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">AbstractApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span>
                        <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="err">「</span><span class="n">spring</span><span class="o">/</span><span class="n">spring</span><span class="o">-</span><span class="n">annotation</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">);</span>

        <span class="n">AnnotationResource</span> <span class="n">annotationResource</span> <span class="o">=</span>
                        <span class="o">(</span><span class="n">AnnotationResource</span><span class="o">)</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="err">「</span><span class="n">annotationResource</span><span class="err">」</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">type</span><span class="o">:</span> <span class="o">{},</span> <span class="n">name</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationResource</span><span class="o">.</span><span class="na">getFlower</span><span class="o">().</span><span class="na">getClass</span><span class="o">(),</span> <span class="n">annotationResource</span><span class="o">.</span><span class="na">getFlower</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">type</span><span class="o">:</span> <span class="o">{},</span> <span class="n">name</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationResource</span><span class="o">.</span><span class="na">getTree</span><span class="o">().</span><span class="na">getClass</span><span class="o">(),</span> <span class="n">annotationResource</span><span class="o">.</span><span class="na">getTree</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><p data-pid="DrJZIrDA">xml 的配置</p><div class="highlight"><pre><code class="language-xml"><span class="c">&lt;!-- 测试@Resource --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「flower」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.Flower」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「tree」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.Tree」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「annotationResource」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.beans.annotation.sample.AnnotationResource」/</span><span class="nt">&gt;</span></code></pre></div><ul><li data-pid="w82IDC_T"><b><code>@PostConstruct</code> 和 <code>@PreDestroy</code></b></li></ul><p data-pid="gBSKX_p1"><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 是 JSR 250 规定的用于生命周期的注解。</p><p data-pid="JY9U6TGX">从其名号就可以看出，一个是在构造之后调用的方法，一个是销毁之前调用的方法。</p><div class="highlight"><pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationPostConstructAndPreDestroy</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">AnnotationPostConstructAndPreDestroy</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">call</span> <span class="nd">@PostConstruct</span> <span class="n">method</span><span class="err">」</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">call</span> <span class="nd">@PreDestroy</span> <span class="n">method</span><span class="err">」</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><h3>JSR 330 注解</h3><p data-pid="kn7-Z1a0">从 Spring3.0 开始，Spring 支持 JSR 330 标准注解（依赖注入）。</p><p data-pid="yEC0hiVW">注：如果要使用 JSR 330 注解，需要使用外部 jar 包。</p><p data-pid="IdoeQa4d">若你使用 maven 管理 jar 包，只需要添加依赖到 pom.xml 即可：</p><div class="highlight"><pre><code class="language-xml"><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>javax.inject<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>javax.inject<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span></code></pre></div><p data-pid="nRYpYuGK">@Inject</p><p data-pid="Sox7KNjc"><code>@Inject </code>和<code>@Autowired </code>一样，可以修饰属性、setter 方法、构造方法。</p><p data-pid="z6aE3SM5"><b><i>范例</i></b></p><div class="highlight"><pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationInject</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">AnnotationInject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nd">@Inject</span>
    <span class="n">Apple</span> <span class="n">fieldA</span><span class="o">;</span>

    <span class="n">Banana</span> <span class="n">fieldB</span><span class="o">;</span>

    <span class="n">Orange</span> <span class="n">fieldC</span><span class="o">;</span>

    <span class="kd">public</span> <span class="n">Apple</span> <span class="nf">getFieldA</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fieldA</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFieldA</span><span class="o">(</span><span class="n">Apple</span> <span class="n">fieldA</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fieldA</span> <span class="o">=</span> <span class="n">fieldA</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Banana</span> <span class="nf">getFieldB</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fieldB</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFieldB</span><span class="o">(</span><span class="n">Banana</span> <span class="n">fieldB</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fieldB</span> <span class="o">=</span> <span class="n">fieldB</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Orange</span> <span class="nf">getFieldC</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fieldC</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">AnnotationInject</span><span class="o">()</span> <span class="o">{}</span>

    <span class="nd">@Inject</span>
    <span class="kd">public</span> <span class="nf">AnnotationInject</span><span class="o">(</span><span class="n">Orange</span> <span class="n">fieldC</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fieldC</span> <span class="o">=</span> <span class="n">fieldC</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">AbstractApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span>
                        <span class="k">new</span> <span class="n">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="err">「</span><span class="n">spring</span><span class="o">/</span><span class="n">spring</span><span class="o">-</span><span class="n">annotation</span><span class="o">.</span><span class="na">xml</span><span class="err">」</span><span class="o">);</span>
        <span class="n">AnnotationInject</span> <span class="n">annotationInject</span> <span class="o">=</span> <span class="o">(</span><span class="n">AnnotationInject</span><span class="o">)</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="err">「</span><span class="n">annotationInject</span><span class="err">」</span><span class="o">);</span>

        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">type</span><span class="o">:</span> <span class="o">{},</span> <span class="n">name</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationInject</span><span class="o">.</span><span class="na">getFieldA</span><span class="o">().</span><span class="na">getClass</span><span class="o">(),</span>
                        <span class="n">annotationInject</span><span class="o">.</span><span class="na">getFieldA</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>

        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">type</span><span class="o">:</span> <span class="o">{},</span> <span class="n">name</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationInject</span><span class="o">.</span><span class="na">getFieldB</span><span class="o">().</span><span class="na">getClass</span><span class="o">(),</span>
                        <span class="n">annotationInject</span><span class="o">.</span><span class="na">getFieldB</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>

        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">type</span><span class="o">:</span> <span class="o">{},</span> <span class="n">name</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">annotationInject</span><span class="o">.</span><span class="na">getFieldC</span><span class="o">().</span><span class="na">getClass</span><span class="o">(),</span>
                        <span class="n">annotationInject</span><span class="o">.</span><span class="na">getFieldC</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>

        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><p data-pid="SnmKo8Nr">Java 配置</p><p data-pid="hqjKW7xS">基于 Java 配置 Spring IoC 容器，实际上是 Spring 允许用户定义一个类，在这个类中去管理 IoC 容器的配置。</p><p data-pid="11juBr2U">为了让 Spring 识别这个定义类为一个 Spring 配置类，需要用到两个注解：@Configuration 和 @Bean。</p><p data-pid="n7wBrsr8">如果你熟悉 Spring 的 xml 配置方式，你可以将@Configuration 等价于 \标签；将@Bean 等价于\标签。</p><p data-pid="cnek8nkL">@Bean</p><p data-pid="Yi6uZcHz">@Bean 的修饰目标只能是方法或注解。</p><p data-pid="_-WWrdjs">@Bean 只能定义在@Configuration 或@Component 注解修饰的类中。</p><p data-pid="OMJMIyPm">声明一个 bean</p><p data-pid="86oUq0YR">此外，@Configuration 类允许在同一个类中通过@Bean 定义内部 bean 依赖。</p><p data-pid="JT2OAfHZ">声明一个 bean，只需要在 bean 属性的 set 方法上标注@Bean 即可。</p><div class="highlight"><pre><code class="language-text">@Configuration
public class AnnotationConfiguration {
    private static final Logger log = LoggerFactory.getLogger(JavaComponentScan.class);

    @Bean
    public Job getPolice() {
        return new Police();
    }

    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AnnotationConfiguration.class);
        ctx.scan(「org.zp.notes.spring.beans」);
        ctx.refresh();
        Job job = (Job) ctx.getBean(「police」);
        log.debug(「job: {}, work: {}」, job.getClass(), job.work());
    }
}

public interface Job {
    String work();
}

@Component(「police」)
public class Police implements Job {
    @Override
    public String work() {
        return 「抓罪犯」;
    }
}</code></pre></div><p data-pid="81OrnYpW">这等价于配置</p><div class="highlight"><pre><code class="language-text">&lt;beans&gt;
    &lt;bean id=「police」 class=「org.zp.notes.spring.ioc.sample.job.Police」/&gt;
&lt;/beans&gt;</code></pre></div><p data-pid="wP02jVPO">@Bean 注解用来表明一个方法实例化、配置合初始化一个被 Spring IoC 容器管理的新对象。</p><p data-pid="2zCrFwH9">如果你熟悉 Spring 的 xml 配置，你可以将@Bean 视为等价于&lt;tag&gt;.</p><p data-pid="1P9wa8xC">@Bean 注解可以用于任何的 Spring @Component bean，然而，通常被用于@Configuration bean。</p><p data-pid="vn9ukO2n">@Configuration</p><p data-pid="aOgyne57">@Configuration 是一个类级别的注解，用来标记被修饰类的对象是一个 BeanDefinition。</p><p data-pid="bMwuNijr">@Configuration 类声明 bean 是通过被@Bean 修饰的公共方法。此外，@Configuration 类允许在同一个类中通过@Bean 定义内部 bean 依赖。</p><div class="highlight"><pre><code class="language-text">@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}</code></pre></div><p data-pid="Gvg-kYAU">这等价于配置</p><div class="highlight"><pre><code class="language-text">&lt;beans&gt;
    &lt;bean id=「myService」 class=「com.acme.services.MyServiceImpl」/&gt;
&lt;/beans&gt;</code></pre></div><p data-pid="xpQl11hQ">用 AnnotationConfigApplicationContext 实例化 IoC 容器。</p><h3>Java 配置</h3><p data-pid="NhlFmgWG">基于 Java 配置 Spring IoC 容器，实际上是 <b>Spring 允许用户定义一个类，在这个类中去管理 IoC 容器的配置</b>。</p><p data-pid="8VbPkd1o">为了让 Spring 识别这个定义类为一个 Spring 配置类，需要用到两个注解：<code>@Configuration </code>和<code>@Bean</code>。</p><p data-pid="L7iKFgGR">如果你熟悉 Spring 的 xml 配置方式，你可以将<code>@Configuration </code>等价于<code>&lt;beans&gt;</code>标签；将<code>@Bean </code>等价于<code>&lt;bean&gt;</code>标签。</p><h3>@Bean</h3><p data-pid="Ck3JKprW">@Bean 的修饰目标只能是方法或注解。</p><p data-pid="cq6NExO5">@Bean 只能定义在<code>@Configuration </code>或<code>@Component </code>注解修饰的类中。</p><h3>声明一个 bean</h3><p data-pid="KJPwMBtx">此外，@Configuration 类允许在同一个类中通过@Bean 定义内部 bean 依赖。</p><p data-pid="_YRk8FAt">声明一个 bean，只需要在 bean 属性的 set 方法上标注@Bean 即可。</p><div class="highlight"><pre><code class="language-java"><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnnotationConfiguration</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">JavaComponentScan</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">Job</span> <span class="nf">getPolice</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Police</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AnnotationConfigApplicationContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="n">AnnotationConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">scan</span><span class="o">(</span><span class="err">「</span><span class="n">org</span><span class="o">.</span><span class="na">zp</span><span class="o">.</span><span class="na">notes</span><span class="o">.</span><span class="na">spring</span><span class="o">.</span><span class="na">beans</span><span class="err">」</span><span class="o">);</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">refresh</span><span class="o">();</span>
        <span class="n">Job</span> <span class="n">job</span> <span class="o">=</span> <span class="o">(</span><span class="n">Job</span><span class="o">)</span> <span class="n">ctx</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="err">「</span><span class="n">police</span><span class="err">」</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="err">「</span><span class="n">job</span><span class="o">:</span> <span class="o">{},</span> <span class="n">work</span><span class="o">:</span> <span class="o">{}</span><span class="err">」</span><span class="o">,</span> <span class="n">job</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="n">job</span><span class="o">.</span><span class="na">work</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Job</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">work</span><span class="o">();</span>
<span class="o">}</span>

<span class="nd">@Component</span><span class="o">(</span><span class="err">「</span><span class="n">police</span><span class="err">」</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Police</span> <span class="kd">implements</span> <span class="n">Job</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="err">「</span><span class="n">抓罪犯</span><span class="err">」</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><p data-pid="x1pLaRxg">这等价于配置</p><div class="highlight"><pre><code class="language-xml"><span class="nt">&lt;beans&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「police」</span> <span class="na">class=</span><span class="s">「org.zp.notes.spring.ioc.sample.job.Police」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;/beans&gt;</span></code></pre></div><p data-pid="tep5zwsz">@Bean 注解用来表明一个方法实例化、配置合初始化一个被 Spring IoC 容器管理的新对象。</p><p data-pid="t09sHOAT">如果你熟悉 Spring 的 xml 配置，你可以将@Bean 视为等价于<code>\&lt;beans&gt;</code>标签。</p><p data-pid="TkM6UHFr">@Bean 注解可以用于任何的 Spring <code>@Component</code> bean，然而，通常被用于<code>@Configuration</code> bean。</p><h3>@Configuration</h3><p data-pid="GNEZI5Gk"><code>@Configuration</code> 是一个类级别的注解，用来标记被修饰类的对象是一个 <code>BeanDefinition</code>。</p><p data-pid="35DH2Fqe"><code>@Configuration</code> 声明 bean 是通过被 <code>@Bean</code> 修饰的公共方法。此外，<code>@Configuration</code> 允许在同一个类中通过 <code>@Bean</code> 定义内部 bean 依赖。</p><div class="highlight"><pre><code class="language-java"><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="n">MyService</span> <span class="nf">myService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">MyServiceImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div><p data-pid="75eAvjoT">这等价于配置</p><div class="highlight"><pre><code class="language-xml"><span class="nt">&lt;beans&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">「myService」</span> <span class="na">class=</span><span class="s">「com.acme.services.MyServiceImpl」/</span><span class="nt">&gt;</span>
<span class="nt">&lt;/beans&gt;</span></code></pre></div><p data-pid="p-Lga6p0">用 <code>AnnotationConfigApplicationContext</code> 实例化 IoC 容器。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><noscript><img src="https://pica.zhimg.com/50/v2-cf2aad6c7e10c48694face0b9a81d7d3_720w.jpg?source=2c26e567" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="800" data-original-token="v2-3d410547ce6f42ddec443683b90c9f9e" class="origin_image zh-lightbox-thumb" width="800" data-original="https://picx.zhimg.com/v2-cf2aad6c7e10c48694face0b9a81d7d3_r.jpg?source=2c26e567"/></noscript><div><img src="https://pica.zhimg.com/80/v2-cf2aad6c7e10c48694face0b9a81d7d3_720w.webp?source=2c26e567" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="800" data-original-token="v2-3d410547ce6f42ddec443683b90c9f9e" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://picx.zhimg.com/v2-cf2aad6c7e10c48694face0b9a81d7d3_r.jpg?source=2c26e567" data-actualsrc="https://pica.zhimg.com/50/v2-cf2aad6c7e10c48694face0b9a81d7d3_720w.jpg?source=2c26e567" height="800" data-lazy-status="ok"></div></figure><p></p></span><span id="VirtualCatalogAnchorPoint"></span></span></div></div></span><div><div class="ContentItem-time"><a target="_blank" href="//www.zhihu.com/question/23277575/answer/1936175709690245208"><span data-tooltip="发布于 2025-08-05 21:24" aria-label="发布于 2025-08-05 21:24">发布于 2025-08-05 21:24</span></a>・广东</div><div class="css-jghqwm"><div class="css-8ul1br"><h3 class="css-13e6wvn"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill="#6A5FF3" d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Z"></path><path fill="#fff" fill-rule="evenodd" d="M4.154 4.97a.5.5 0 0 1 .706-.046L7.877 7.57a.2.2 0 0 0 .264 0l2.99-2.616a.5.5 0 0 1 .659.753L8.6 8.496a.9.9 0 0 1-1.186-.001L4.2 5.675a.5.5 0 0 1-.046-.705Z" clip-rule="evenodd"></path><path fill="#fff" fill-rule="evenodd" d="M4.154 8.57a.5.5 0 0 1 .706-.046l3.017 2.646a.2.2 0 0 0 .264 0l2.99-2.616a.5.5 0 0 1 .659.753L8.6 12.096a.9.9 0 0 1-1.186-.001L4.2 9.276a.5.5 0 0 1-.046-.706Z" clip-rule="evenodd"></path></svg><span class="css-lzd0h4">继续追问</span></h3><div class="css-zkfaav"><svg width="14" height="14" viewBox="0 0 24 24" class="ZDI ZDI--ZhidaLogo24 css-1wz4adt" fill="currentColor"><path d="M21.37.96a.245.245 0 0 1 .46 0l.413 1.115c.082.223.259.4.483.483l1.114.412a.245.245 0 0 1 0 .46l-1.114.412a.817.817 0 0 0-.483.483L21.83 5.44a.245.245 0 0 1-.46 0l-.412-1.115a.818.818 0 0 0-.483-.483L19.36 3.43a.245.245 0 0 1 0-.46l1.115-.412c.223-.083.4-.26.483-.483L21.37.96ZM14.675 14.738a2.02 2.02 0 0 0 .05-.127l1.584-4.46a1.59 1.59 0 0 0-1.499-2.122h-3.05c-.715 0-1.363.381-1.715.981l.01-.021c.392-.887 1.223-2.766 2.625-4.07 1.648-1.531 4.286-1.28 6.035.136 2.507 2.029 3.717 5.515 2.525 8.895-1.434 4.068-5.478 6.79-9.792 6.79h-.143c1.805-1.424 2.818-4.207 3.37-6.002Z"></path><path d="M.752 7.655.167 9.317.2 9.312C1.104 8.017 2.6 8.02 5.302 8.024H5.534L1.05 20.74H7.275c.264-.027.607-.043 1.041-.043 3.86 0 5.464-3.838 6.138-5.452.063-.15.118-.282.166-.39a1.988 1.988 0 0 1-1.768 1.08H11.56c-.592 0-1.171.176-1.663.506l-.776.521a.124.124 0 0 1-.185-.143l.25-.716a.127.127 0 0 0-.12-.169 1.07 1.07 0 0 1-1.01-1.428l1.83-5.153c.017-.047.035-.093.055-.138.061-.184.122-.376.185-.572.591-1.851 1.333-4.173 3.756-5.354H6.726c-3.923 0-5.018 1.767-5.584 3.256l-.237.673c-.052.155-.102.302-.153.438Z"></path></svg><span class="css-1wk6wx3">由知乎直答提供</span></div></div><div class="css-vurnku"><a href="https://zhida.zhihu.com/search?content_id=740688980&amp;content_type=ANSWER&amp;is_preview=1&amp;q=IoC+%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9F&amp;zhida_source=below_banner_question" target="_blank" class="css-52qorg"><p class="css-i0heim">IoC 容器如何改变编程思想？</p><svg width="16" height="16" viewBox="0 0 16 16" class="css-1z0nv58" fill="none"><path fill="#6A5FF3" fill-rule="evenodd" stroke="#6A5FF3" stroke-linecap="round" stroke-width=".467" d="m10.38 12.992 3.995-4.66a.497.497 0 0 0 0-.663L10.38 3.008a.5.5 0 1 0-.76.65L12.913 7.5H2.667a.5.5 0 0 0 0 1h10.246L9.62 12.341a.5.5 0 0 0 .76.651Z" clip-rule="evenodd"></path></svg></a><a href="https://zhida.zhihu.com/search?content_id=740688980&amp;content_type=ANSWER&amp;is_preview=1&amp;q=IoC+%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E6%80%A7%EF%BC%9F&amp;zhida_source=below_banner_question" target="_blank" class="css-52qorg"><p class="css-i0heim">IoC 容器如何提高代码复用性？</p><svg width="16" height="16" viewBox="0 0 16 16" class="css-1z0nv58" fill="none"><path fill="#6A5FF3" fill-rule="evenodd" stroke="#6A5FF3" stroke-linecap="round" stroke-width=".467" d="m10.38 12.992 3.995-4.66a.497.497 0 0 0 0-.663L10.38 3.008a.5.5 0 1 0-.76.65L12.913 7.5H2.667a.5.5 0 0 0 0 1h10.246L9.62 12.341a.5.5 0 0 0 .76.651Z" clip-rule="evenodd"></path></svg></a><a href="https://zhida.zhihu.com/search?content_id=740688980&amp;content_type=ANSWER&amp;is_preview=1&amp;q=IoC+%E5%AE%B9%E5%99%A8%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E7%A8%8B%E5%BA%8F%E8%80%A6%E5%90%88%E5%BA%A6%EF%BC%9F&amp;zhida_source=below_banner_question" target="_blank" class="css-52qorg"><p class="css-i0heim">IoC 容器如何降低程序耦合度？</p><svg width="16" height="16" viewBox="0 0 16 16" class="css-1z0nv58" fill="none"><path fill="#6A5FF3" fill-rule="evenodd" stroke="#6A5FF3" stroke-linecap="round" stroke-width=".467" d="m10.38 12.992 3.995-4.66a.497.497 0 0 0 0-.663L10.38 3.008a.5.5 0 1 0-.76.65L12.913 7.5H2.667a.5.5 0 0 0 0 1h10.246L9.62 12.341a.5.5 0 0 0 .76.651Z" clip-rule="evenodd"></path></svg></a></div></div></div><span></span><div><div class="ContentItem-actions Sticky RichContent-actions is-fixed is-bottom" style="width: 694px; bottom: 0px; left: 16px;"><span><span><button aria-label="赞同 1 " aria-live="polite" type="button" class="Button VoteButton FEfUrdfMIKpQDJDqkjte"><span style="display: inline-flex; align-items: center;">​<svg width="10" height="10" viewBox="0 0 24 24" class="Zi Zi--TriangleUp VoteButton-TriangleUp" fill="currentColor"><path fill-rule="evenodd" d="M13.792 3.681c-.781-1.406-2.803-1.406-3.584 0l-7.79 14.023c-.76 1.367.228 3.046 1.791 3.046h15.582c1.563 0 2.55-1.68 1.791-3.046l-7.79-14.023Z" clip-rule="evenodd"></path></svg></span>赞同 1</button></span><button aria-label="反对" aria-live="polite" type="button" class="Button VoteButton VoteButton--down FEfUrdfMIKpQDJDqkjte"><span style="display: inline-flex; align-items: center;">​<svg width="10" height="10" viewBox="0 0 24 24" class="Zi Zi--TriangleDown" fill="currentColor"><path fill-rule="evenodd" d="M13.792 20.319c-.781 1.406-2.803 1.406-3.584 0L2.418 6.296c-.76-1.367.228-3.046 1.791-3.046h15.582c1.563 0 2.55 1.68 1.791 3.046l-7.79 14.023Z" clip-rule="evenodd"></path></svg></span></button></span><button type="button" class="Button ContentItem-action FEfUrdfMIKpQDJDqkjte Button--plain Button--withIcon Button--withLabel fEPKGkUK5jyc4fUuT0QP B46v1Ak6Gj5sL2JTS4PY RuuQ6TOh2cRzJr6WlyQp"><span style="display: inline-flex; align-items: center;">​<svg width="1.2em" height="1.2em" viewBox="0 0 24 24" class="Zi Zi--Comment Button-zi t2ntD6J1DemdOdvh5FB4" fill="currentColor"><path fill-rule="evenodd" d="M12 2.75a9.25 9.25 0 1 0 4.737 17.197l2.643.817a1 1 0 0 0 1.25-1.25l-.8-2.588A9.25 9.25 0 0 0 12 2.75Z" clip-rule="evenodd"></path></svg></span>添加评论</button><div class="Popover ShareMenu ContentItem-action"><div class="ShareMenu-toggler" id="Popover13-toggle" aria-haspopup="true" aria-expanded="false"><button type="button" class="Button FEfUrdfMIKpQDJDqkjte Button--plain Button--withIcon Button--withLabel fEPKGkUK5jyc4fUuT0QP B46v1Ak6Gj5sL2JTS4PY RuuQ6TOh2cRzJr6WlyQp"><span style="display: inline-flex; align-items: center;">​<svg width="1.2em" height="1.2em" viewBox="0 0 24 24" class="Zi Zi--Share Button-zi t2ntD6J1DemdOdvh5FB4" fill="currentColor"><path d="M19.47 1.914a.8.8 0 0 1 1.204.778l-1.872 16.386a.9.9 0 0 1-1.204.743l-4.615-1.692a.7.7 0 0 0-.831.28l-1.927 3.02c-.43.674-1.474.369-1.474-.43v-3.865a.8.8 0 0 1 .179-.504l5.808-7.148a.595.595 0 0 0-.897-.781l-5.93 6.354a1.1 1.1 0 0 1-1.258.252L2.57 13.46a.8.8 0 0 1-.08-1.415l16.98-10.13Z"></path></svg></span>分享</button></div></div><button type="button" class="Button ContentItem-action FEfUrdfMIKpQDJDqkjte Button--plain Button--withIcon Button--withLabel fEPKGkUK5jyc4fUuT0QP B46v1Ak6Gj5sL2JTS4PY RuuQ6TOh2cRzJr6WlyQp"><span style="display: inline-flex; align-items: center;">​<svg width="1.2em" height="1.2em" viewBox="0 0 24 24" class="Zi Zi--Star Button-zi t2ntD6J1DemdOdvh5FB4" fill="currentColor"><path d="M10.484 3.307c.673-1.168 2.358-1.168 3.032 0l2.377 4.122a.25.25 0 0 0 .165.12l4.655.987c1.319.28 1.84 1.882.937 2.884l-3.186 3.535a.25.25 0 0 0-.063.193l.5 4.733c.142 1.34-1.222 2.33-2.453 1.782l-4.346-1.938a.25.25 0 0 0-.204 0l-4.346 1.938c-1.231.549-2.595-.442-2.453-1.782l.5-4.733a.25.25 0 0 0-.064-.193L2.35 11.42c-.903-1.002-.382-2.604.937-2.884l4.655-.987a.25.25 0 0 0 .164-.12l2.378-4.122Z"></path></svg></span>收藏</button><button aria-live="polite" type="button" class="Button ContentItem-action FEfUrdfMIKpQDJDqkjte Button--plain Button--withIcon Button--withLabel fEPKGkUK5jyc4fUuT0QP B46v1Ak6Gj5sL2JTS4PY RuuQ6TOh2cRzJr6WlyQp"><span style="display: inline-flex; align-items: center;">​<svg width="1.2em" height="1.2em" viewBox="0 0 24 24" class="Zi Zi--Heart Button-zi t2ntD6J1DemdOdvh5FB4" fill="currentColor"><path fill-rule="evenodd" d="M17.142 3.041c1.785.325 3.223 1.518 4.167 3.071 1.953 3.215.782 7.21-1.427 9.858a23.968 23.968 0 0 1-4.085 3.855c-.681.5-1.349.923-1.962 1.234-.597.303-1.203.532-1.748.587a.878.878 0 0 1-.15.002c-.545-.04-1.162-.276-1.762-.582a14.845 14.845 0 0 1-2.008-1.27 24.254 24.254 0 0 1-4.21-4.002c-2.1-2.56-3.16-6.347-1.394-9.463.92-1.624 2.362-2.892 4.173-3.266 1.657-.341 3.469.097 5.264 1.44 1.75-1.309 3.516-1.76 5.142-1.464Z" clip-rule="evenodd"></path></svg></span>喜欢</button><div class="Popover ContentItem-action"><button aria-label="更多" id="Popover14-toggle" aria-haspopup="true" aria-expanded="false" type="button" class="Button OptionsButton FEfUrdfMIKpQDJDqkjte Button--plain Button--withIcon Button--iconOnly fEPKGkUK5jyc4fUuT0QP B46v1Ak6Gj5sL2JTS4PY hIwDV_tcL6XN1HprrnAq"><span style="display: inline-flex; align-items: center;">​<svg width="1.2em" height="1.2em" viewBox="0 0 24 24" class="Zi Zi--Dots Button-zi t2ntD6J1DemdOdvh5FB4" fill="currentColor"><path d="M6 10.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3ZM10.5 12a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0ZM16.5 12a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z"></path></svg></span></button></div><button data-zop-retract-question="true" type="button" class="Button ContentItem-action ContentItem-rightButton FEfUrdfMIKpQDJDqkjte Button--plain fEPKGkUK5jyc4fUuT0QP"><span class="RichContent-collapsedText">收起</span><span style="display: inline-flex; align-items: center;">​<svg width="24" height="24" viewBox="0 0 24 24" class="Zi Zi--ArrowDown ContentItem-arrowIcon is-active" fill="currentColor"><path fill-rule="evenodd" d="M17.776 10.517a.875.875 0 0 1-.248 1.212l-5.05 3.335a.875.875 0 0 1-.964 0L6.47 11.73a.875.875 0 1 1 .965-1.46l4.56 3.015 4.568-3.016a.875.875 0 0 1 1.212.248Z" clip-rule="evenodd"></path></svg></span></button><button class="Button ContentItem-action copy-full-text-btn FEfUrdfMIKpQDJDqkjte Button--plain Button--withIcon Button--withLabel">
            <span style="display: inline-flex; align-items: center;" class="copy-icon">
                <svg width="1.2em" height="1.2em" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 4H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 14H5V6h14v12z"></path>
                    <path d="M7 8h10v2H7zm0 4h10v2H7z"></path>
                </svg>
            </span>复制全文</button></div><div class="Sticky--holder" style="position: static; inset: auto; display: flex; float: none; margin: 0px -20px -10px; height: 53.9px; width: 694px;"></div></div></div><div><div><div class=""></div><div class="ModalLoading-content"><svg width="30" height="30" viewBox="0 0 66 66" xmlns="http://www.w3.org/2000/svg" class="CircleLoadingBar  css-1od72gz" aria-hidden="true"><g><circle class="path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></g></svg></div></div></div></div></div></div></div>