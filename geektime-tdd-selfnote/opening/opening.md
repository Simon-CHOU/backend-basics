 Terms
 JAX-RS（Jakarta Restful WebService）
 “调试”是一种启发式过程（Heuristic Procedure），更像是探索测试（Exploratory Testing）
 
 因为测试是如此重要，我们需要非常高效地实现它们。那么“无计划的手动验证”与“手动的启发式定位”都是无法容忍的低效手段，必须将它们替换为“有计划的自动化验证测试”和“有计划的逐模块自动化排查”。从而才有了我们熟知的测试驱动开发（红 / 绿 / 重构循环），以及令没有做过测试驱动开发的人费解的对于自动化的偏执。



 困扰：测试从哪里来？为什么我写了很多测试，功能却没有进展？写什么样的测试既能驱动功能进展，又不会在重构中被破坏？社区里很多人都非常推崇单元测试，但我就是要测一段 SQL，单元测试怎么测？


 测试驱动开发从来都不是一种即插即用的技能，它是一种工作习惯和思维方式，背后还对深层的胜任力（Competency）——分析性思考有极高的要求。某种程度上讲，测试驱动开发有点像物理，定理写出来很简单，但需要我们在不同的场景下练习，才能应用得得心应手。

 编码练习（Code Kata）
 dojo 同理。

 我们会介绍 TDD 的经典学派（芝加哥学派）与伦敦学派不同的切入点。
 
 从 2003 年开始，我就将测试驱动开发作为主要工作方式了。
 在加入 Thoughtworks 之后，对内对外我讲述了大量测试驱动开发的课程。曾经有一段时间，每一位新入职的 Thoughtworker 我都会通过 6 周的时间，教会他们进行测试驱动开发。
 当我主持 Thoughtworks 委培生计划——小巨人项目（Small Giant Program）时。测试驱动开发与学习管理，是最早也是最重要的工作习惯。近年我研发的高效能工程方法 SEELE（Scalable Engineering Experience for Large Enterprise）也是将测试驱动开发作为核心流程，从而简化知识传递成本并提高杠杆率。


 DD 的一大学习困难点就在于，会 TDD 的人对其中的妙处有着非常强烈的主观体验，而不会 TDD 的人，则体会不到。所以最佳的学习路径，就是由熟练者来指导新人。那么课程的第一个设计亮点，通过视频的形式来演示用 TDD 实现项目开发的全过程。


 在团队里的新手学 TDD 的时候，我会让他们自己敲一遍代码，然后录个视频发给我。最后发现很多人做错了，他们都是先写实现再写测试。所以如果有视频的话，他们至少不会犯这个错误。

 其中第一个项目是演示参数行命令解析的例子。这个例子源自 Bob 大叔那本广为流传的书——Clean Code。这是一个编程练习级别的例子，非常简单。目的是让你眼见为实，亲眼看一看真正的 TDD 是怎么驱动开发的，从而对真正的 TDD 有个感性且直观的认识。

 在这个项目之后，我们将进入 TDD 的完全实战环节，老师会带着你使用 TDD 的方式去实现工作中常用的 3 个技术框架，包括 IoC 容器、RESTful、SQL mapper。


 那么看看视频、跟着敲敲代码，能学会 TDD 吗？显然不能。要知道，课程中的所有代码，我们并没有放在 GitHub 或者 Gitee 上。这样做的意图在于，希望你能在观看完徐老师的演示视频之后，开动下自己的小脑筋，亲自动手再去写一遍。写完之后，可以将你与老师写的代码进行对比。这个有效的学习方法也可以总结为“一看二动三对比”。另外，徐老师特地邀请了他 Thoughtworks 的两位同事作为课程的审稿人，分别是王晓峰老师和郑茗蔓老师

 相反，在项目组做 CRUD 时，从技术上看，我们就是在做 CRUD。但与此同时，还需要理解“我为什么要做 CRUD”。这就牵扯到应该如何理解业务上下文和业务逻辑等问题。

 随着业务的发展，很少会出现一次性的、代码写完就完成了的情况。因而在项目组做 CRUD 时，写代码可能仅仅占据整个代码生命周期的 5%。剩下的 95%，都是根据需求变化和功能调整，在 CRUD 的基础上再不断迭代。


 再来讲一个比较极端的情况。假设在项目中出现“需求不会做”的情况，此时你面临着两个选择：一是马上向别人求助；二是先自己死磕，实在不行了再找人帮忙。我看弹幕里大多数人选择的是后者。
 先说我的结论。如果在我的团队里，我希望你能选择前者。事实上，无论我是 TL 还是团队中的其他人，都希望你能选择前者。选择前者，代表你的技术能力可能较弱，完成不了需求，但却有着非常强的工程能力。
 因为工程能力强的第一步，就是不要成为别人的绊脚石。

 向别人求助，难道不会浪费别人的时间吗？我要说的是：这不是由你决定的。作为项目的 TL 或者 PM，他会统一全篇的安排，看看是让你继续憋一憋，还是交由其他人来做。如果其他人也不会，可能就需要去请外脑。

 从个人的工程能力讲，构建一种信任关系，不去成为别人的绊脚石，这是程序员最重要的素养。但是在实际工作中，我们很少考虑这样的问题。当然，我们举的是一个极端的例子，目的是帮助你理解，当我们强调技术和工程能力时，能够极端到何种情况。

 我可以将工程能力总结为：在团队协作环境下，长期稳定输出，并持续提高水平的能力。

 “协作”的行为。换句话说，工程能力要求我们怎样才能变成一个更好的 Team  Player。工程能力的第二个要求是长期稳定。


 我们的生产效率之所以变得越来越慢，之所以出现不敢改祖传代码的情况，是因为所做的修改一旦出错，就无法定位到底是因为什么出的错。


 我在做咨询时经常会进行类似的尝试。我会将团队里的开发工程师分别叫到不同的房间，让他们对将要迭代的功能进行任务分解。最后发现，五个人分解出了五种不同的样子。实际上就表明这个团队的架构师没有做任何工作。

 架构是整个软件开发过程中最奇怪的一类产出，它本身不发挥任何价值，而只能指导别人的工作。我们只有理解了架构是什么，才能写出正确的架构和正确的代码。当我们说这个架构产生了，如果只存在于纸上，那它不会发挥任何作用。或者说这可能是一个非常容易被破坏的架构愿景。只有架构进入到每个人的头脑中，指导工程师进行具体工作的时候，它才能够发挥作用。


 在我们软件行业，大家非常关注自己个人的技术水平，而不强调工程实践的能力。所以我们行业里普遍缺乏这两种能力：给我一个需求，我能够恰如其分地分解成对应的功能点；给我一个架构愿景，我可以把功能点切分成对应的功能上下文。
 怎么获得这些能力呢？最简单的办法就是练！你可以把 TDD 看成一种训练手段。当你在每一次实践中去强调 TDD，那么最终会变成一个更好的程序员，因为你一直在锤炼程序员工程化水平的最核心的能力。


 在自学 TDD 时，我把 Kent Beck 的书看了很多遍。当看到第 30 遍时，突然发现书里有一个非常小的列表，一直在说明下一步要做什么。虽然书中有一个章节都在讲任务列表，但在很长一段时间里，我都没有将任务列表与测试直接关联在一起。后来再回过头思考，才发现原来 TDD 是先产生一个任务列表，而我可以在任务列表上再进一步分解，分解成能够被测试的任务。我花了很长时间来琢磨这件事。同样，这也是很多同学在学习 TDD 时遇到的一个大的困难点。
 经过一年多的训练，我才觉得差不多掌握了 TDD。所以它的确是非常难掌握的一种开发方法。

 当思考职业发展时，我建议不要把眼睛仅仅盯在技术能力上。比如 AI，需要追吗？除非你想立志成为 AI 工程师，否则更需要问的是：AI 何时会工程化？当 AI 工程化后，将会以何种形式与软件工程发生关系？当 AI 进入软件行业，我们做事的方法和风格会发生何种改变？应该知道，去规划自己的职业生涯时，技术能力和工程能力是同等重要的，但工程能力却是我们长期忽视的和欠缺的。从根本上讲，就是不光要注重自己的技术能力，同时也要注重自己的工程能力。那么 TDD 是我认为目前效能最高的工程化的开发方法，当然，它也是难以掌握的。
 